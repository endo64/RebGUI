REBOL [
	title: "drop-tree"
	author: rsmolak@gmail.com
	version: 0.0.9
]

tree-images: reduce [

'node-open load to-binary decompress 64#{
eJyV0/0z2wccwPHP9xsV1EPiIbZISXO0RSyXiWgeKsxDpFe0RbOSLoyRRCQxdKth
4ehtKaYtEjSkylU2ruPww7azsCt5EBqbedjW6abXrvul5263rivfxZ+w171/+Hx+
+Pz4EYoyTnKKAyEQ/gbA3F59j/05ge30Ytst2MNubOsGttmIrX+MrV/B1hqxtXps
rQ57oMJWVNiyEnPKMYcMc5RhdhlmL8fs7uE9zF66v9Wxv9G2v3p53yHfd8j2Nq7t
ORR7dvmevXzPJntlV/y7VPXyp4GXDvULm+aFVf3XStvu75O7D8d2Hdrnv44/nW94
OtfwZO6jJ5banRnJb7P1v0xrfh4/v/WdftOcu2k+uzksWL9XsX5H8IPp1OpQhmus
wnXnjGso22VKdQ0muQb4D0wZK1PNK0bBipG/fOuU05jiNCY7+/nOPu7SFzVLvYkO
A9vey7f38uwGvs3Asxm4Nj3HapJYDTyrnmvVn7T2cBe/HVwcUS0akhe7Excm2xf0
/IXuhPtd7Ps3WbPDH862M7/Ri79uY850ZMx0pM9cjZ1upU9N9EyN3ZxqZU6OdU/o
0u51Kca71GZ93aiueLRZYDJ9NtgkNjbm39JE9jXm99Zy9DWcnvr8LuWJa1XZuuo8
XdW5T1Xpn1RmactE2lKuVhrZoBJfURV9kBd1WcKuvRhZc4Fa/XaCpup9jTRTXXZW
XZylkgor3ZSKSqW8UlGqLMmpUCoVF3lyWZlMJisvLy/LZpQUpBWnRxVlp1ySSiVn
eJLMOImQXlhQUCggF6QmiIXMXGG8SJT+FoOcIuAmvcng0am82ChOTATnOCXxeDib
Hc+OYyRQSazoIyxqaDydzggLiqaRoqmUaOrrJ0jEqGPHaBERtBBCOIUcFuAXigMS
DkJwEOwOhWAEgnAQhECgl3cgCkQ8nogDIgABhxBwQECBABCAQgACAQD+AH4o+AH4
oqgvCr4Ah1E4DOAD4A3ghaJeAHgPDzyAJ4J4InDIHYAHAA4B1B0gKADiBgcsFgv8
H0f/8XAfPgf6wXLwE8lez+CRd4v47jljkxfxR1ezJQUJUVKP0nKHrXpa3nLeaYMm
K4VTnSd6F6d2kpv6P2fdnr8h9I2QytrM1Z0mShKDzO3chowhNt//epp1gdBOYgVM
ylldRRDX7j/iff7649AYaafHXI2mnYIGzu9SmNs5g7rOvhhlpNAT9Ssk/IGMkML7
U9/xHdgxfOl6LeZS/c5orqiDxGE9ajotseEdi7GFPkPm1hZtwtXgEVcTscQhwIeZ
NzikVB3X8FURvTqT2s9NI+se24aDO2i3n71RGRs2R+XXKXano+8e8smpK2Uemb2w
atEC7z8YC5PbDQQAAA==
}

'node-closed load to-binary decompress 64#{
eJx90/lP03cYB/Dn25YeCFgo4jhXsyrHZoDCCrSI1AoIA5SwzYJliByt0ELLIRNL
hw0kgK4IxAwKugwYFJXEyIa6oJYz0AJylDkEjxWZbGZMGY0o0M/KP7BXnrzzfpLn
1ycqOjI4JM0BHOAtANpmRmgLmSbRy2ZkVKOn36AnSvS4Ds2Wo1kFmi1FhmI0U4Cm
5Wi6GE1J0WQuGhejMRHSZyO9JbOQToR0QqSzlEykyzDP15h/u2B+VG0eyzHrs816
0ZY+e2tUtLnxblOXvbGx/n5M9l4vXTdq1kfy3o5KTZOqNZNpdfX1m/n2f552rjxu
Wxkq+POvV0v3ZUt3pS9eLBqNxmfPnj/pkSzclS/0FCx08ed78ue7Eufm5h/dKvm1
O3/WMDN7M8/QozS08ma6iqZbIqdu5DzsVk5MjE+MT06MTYw3hY4O9Y1qvx9t5I02
cEaGR0YGtEODwwMP7vVr5H0P+rSthb21nJ6mvJ/Vhd2d1Tfbq65/m369gnOtQ3Ot
MqqzraK94ki7POjHqtS28mMtLa1X5byrUr8rjWVNMra6Ua0u4jbKjzecib58ll93
oabunKC2tv5SUXRNfqxKdUlVKrkojaqWJVSeV1RKeJXi+DJZkuJMQWlG2LmshLNF
suLCnMKiwsJEv3ypSJqfL81IysvNyTspyJVk5sb6SnIlEvFpSeoJcU6GOFWQIxZn
C9Oz41mnRVkikUgoFGYmxmVG+ZxKCPsqjp2SmpoSwUzheqdwXAWHAwUHGQK284nk
ZD7H48ugD784wkzghR71t4nfT4j1J8UEecX4W0ezA7nebuGswAOB/hw/T3Ywi/0x
I4ThEsxwD/L0YLE+Zfm4s7wYTIYrk+7EpDv6f+Tqt8fF19l+v4u9D93Z28tzn6uT
q53tbjzsxoGTBQ52WQYDRxw4WhKAhgMaBg5ksgMO7IkkewzsAagWeIyKAyoGVICd
GOwEsLMAsLWgWNtiYAtgg+FsMLAB2IHBDgBrAIoVgYLHUwDIACQSkQRAJOCJGEYE
sAIgAOAAMNim1Wrhf+15R7BcmuCT7WX7J8LJCF5RbpCGHzb74Gl2zel7zxMI/nfI
6hlcWcTejvvkX1r80i4HKAa/nsuixO6qV/gk9xrJBheXUPU6tPxxURtQ8pyaRucq
rSjMlbLfDaSx8IMxa5oS3mBMcwjB1OCoEWppEWIxfyFmyWEfM2Iy3GpxqKyi+8Bx
alliRJVnWCTHuHaLh+Hd2zO81cm+qisBxXeW02i3W7VcpwrGqoFI/i6spE4zlT4z
7fZZ8m2cxjiS6OIVV93QGOBJUTqeIsz1/eCsdfs8qTd8dqDl5RzN46TmDT5c18lU
EJRT+PKOoz9xNzdfH9ZI79UrVpaPUfv6seCYxQ+c+JkqD182edm236Sr+ffvgk36
Ib4vHTj/AWSrv6MwBAAA
}

'bar load to-binary decompress 64#{
eJxz93SzsEwUYhBi+M7AwNACAv9HwSgYkUDxJwsjMBcw6IAIUJ5g4NBjYOSQ4VBg
ONjMIaxlk1Gw8HA7i7TTnBUBSke7mXWT9qwofHykT06+iWdngcrJBgYGawBY6g6k
UQMAAA==
}

'item load to-binary decompress 64#{
eJxz93SzsEwUYhBi+M7A8P///39///39+/cPEPz+8/vX71+/foLAj58/fvz49vXb
VyD48vXr56+fP33+/PHzp4+fPrz/8P7d+3dv3715/ebNqzevX71+9fLVqxevXjx7
8fzZ8+dPXzx/+vzZ02dPnzx9+vjpk0dPHj98/OjBo4dAdB+IHj4AontA9OA+EN19
cPf2vTu37t65eec2CN2+dQOIbt28CUQ3b16/dfP6zRvXbl6/euPalWtXL1+9cgmI
rly+eOXShUsXzl28cPbi+bPnz54+d+bk2dMnzpw4fvLQ/sM7t+/aunXrxg0b165Z
t2bNmtWrVi9csHDBvAXz5y+YPXv2tGnTJk2a1NvT297W0dba3trS1tzcXFtTW1NT
U1VZXVVZVV5WXlZWXlpaVlRUVAAE+YVZWVmZmZlpaWmpKWkpKSnJyclJSUkJCQlx
MXFRQBAZFRERER4eER4WHhYWFhISEhwcHBQUFBAQ6B/g7wcCvkDg4+Pj7e3t6enl
4eHh7u7u6urq4uLi7Ozs5OTk4OBgZ2dnbW1jbW1tYWlhbm5uZmampaWlqampoaGh
rqEOBGpqaqqqqvLy8nJycrJysjIyMtLS0lJSUhISEgICAry8vDw8PNzc3Ozs7Kys
rMzMzAwMDAcOHGAYBYSA4k8WRgaGeQw6IA4oTzhwHGGw5ZTx2PDggK6PicaFBY1H
utpNMu4ccGzmEm1mmi9zMOIDhwgng4gGg+bDE8JqbhxSE4tavebqujUwfJx4jHdK
L5ut1wQGVU+vZk+7vjsnJzzkEpI2MViY9IRLSdPCaElFx+Ksq9qeMx7IaLRyMsjk
HTN46PGhQ0Qj5bQXo+Slxf4LnMqFzgo4NruvVXuapvHqw0MuKc0FNo4rJiTe3y+k
GSXj0do/W9vl3ymWpsenRDXM2dfVNCV7z1Vy2eZxsyvwlLCW56Qlsb4GCgzWABQG
aC/nAwAA
}

'corner load to-binary decompress 64#{
eJxz93SzsEwUYhBi+M7AwNACAv9HwSgYkUDxJwsjMBcw6IAIUJ5g4NBjYOSQ4VBg
ONjMIaxlk1Gw8HA7i7TTnBUBSke7mXmzdE5cVDrWr+DcJeO5acmBBgYGawBNgQ5F
UQMAAA==
}

'tee load to-binary decompress 64#{
eJxz93SzsEwUYhBi+M7AwNACAv9HwSgYkUDxJwsjMBcw6IAIUJ5g4DBiYOSQ4VBg
ONjMIaxlk1Gw8HA7i7TTnBUBSke7mXmzdE5cVHJrk3eu4uEsVPFsV/Nn4uBgsAYA
b4gMtVUDAAA=
}


'corner-minus load to-binary decompress 64#{
eJxz93SzsEwUYhBi+M4ABi0g8H8UjIKRBxR/sjAyMDAy6IAyAihPMHB4MzBzyEg4
MBxs5hDWsskoWHi4nUnJa8qOgAMN3RLsJj4Zho+P9nJYV7GcLGBomKxuKhazMzDF
bRJLbFKLZcCz413C6nZ3Tm5efn6+HTMTgzUApEwXJW4DAAA=
}

'corner-plus load to-binary decompress 64#{
eJxz93SzsEwUYhBi+M4ABi0g8H8UjIKRBxR/sjAyMDAy6IAyAihPMHD4MzBzyEg4
MBxs5hDWsskoWHi4nUnJa8qOgAMN3RLsJj4ZH5UYeqQFy2Q+fEzyaFNhXPEnY0Pq
wUZl76w1HYHPPJuUje+1WBY+OjzfoZlLVstEgcEaADGTGYVyAwAA
}

'tee-minus load to-binary decompress 64#{
eJxz93SzsEwUYhBi+M4ABi0g8H8UjIKRBxR/sjAyMDAy6IAyAihPMHD4MjBzyEg4
MBxs5hDWsskoWHi4nUnJa8qOgAMN3RLsJj4Zho+P9nJYV7GcLGBomKxuKhazMzDF
bRJLbFKLZcCz413C6nZ3Vk5QOz9fu/EdDweDNQDSCBfOcAMAAA==
}

'tee-plus load to-binary decompress 64#{
eJxz93SzsEwUYhBi+M4ABi0g8H8UjIKRBxR/sjAyMDAy6IAyAihPMHAEMTBzyEg4
MBxs5hDWsskoWHi4nUnJa8qOgAMN3RLsJj4ZH5UYeqQFy2Q+fEzyaFNhXPEnY0Pq
wUZl76w1HYHPPJuUje+1WBY+Ojyfq5xJ9tekF+cbGBisAY7hHIN1AwAA
}

]

drop-tree: make rebface [
	expander-button-spec: [
		size: 9x9
		edge: none
		color: colors/widget
		id: none
		font: make default-font [
			size: 9
			offset: 0x0
			color: black
		]
		para: make default-para [
			origin: 0x0
			wrap?: false
		]
		feel: make default-feel [
			over: func [face act pos][
				face/font/color: pick reduce [orange black] act
				show face
			]
			detect: func [face event][
				if event/type = 'up [
					face/parent-face/active?: false
					face/action face
					return none
				]
				event
			]
			engage: func [face act event][
				case [
					event/double-click [face/dbl-action face]
					act = 'down [
						clear-expander
						face/color: green
						show face/parent-face
						face/parent-face/active?: true
					]
				]
			]
		]
		action: func [face /local tp] [
			tp: root-face/tree-box/tree-pane
			tp/data: tp/parse-tree/level root-face/data face/id

			check-sliders

			either show-tree [
				do-events
			][
			 	show tp/parent-face
			]
		]
	]
	expander-spec: [
		offset: 0x0
		edge: default-edge
		size: 18x18
		active?: false
		init: has [but pos] [
			pane: copy []
			pos: 0x0
			repeat n 4 [
				but: make rebface expander-button-spec
				if root-face/expander-mode = 'big [
					but/size: 18x18 but/font/size: 12 but/para/origin: 2x2
				]
				but/offset: pos
				but/text: form 1 + but/id: n
				insert tail pane but
				pos: pos + either root-face/expander-mode = 'small [9x0][18x0]
				if all [root-face/expander-mode = 'small pos/x > 9] [
					pos: pos + -18x9
				]
			]
			expander-button-spec: none
			if root-face/expander-mode = 'big [
				size: size * 4x1
			]
			size: size + (edge/size * 2)
		]
	]

	drop-arrow-spec: [
		offset:	as-pair root-face/size/x - root-face/size/y + 2 2
		size:	as-pair root-face/size/y - 4 root-face/size/y - 4
		edge:	none
		type:	'down
		data:	'down
		action:	func [face] [
			either show-tree [
				do-events
			][
				hide-tree
			]
		]
	]

	input-field-spec: [
			text: ""
			edge: default-edge
			font: default-font
			para: default-para
			feel: make edit/feel [
				detect: func [f e][
					if e/type = 'up [
						either show-tree [
							do-events
						][
							hide-tree
						]
					]
					e
				]
			]

			focus-action: :on-focus
			unfocus-action: :on-unfocus

			init: does [
				offset:	0x0
				size: root-face/size
				color: colors/edit
				para: make para []
				if root-face/expander-mode = 'big [
					para/origin/x: 4 * 18 + 2
				]

			]
	]

	tree-vslider-spec: [
		size: (as-pair 16 p/size/y);  - (2 * p/edge/size)
		options: [arrows]
		action: does [
			p/tree-pane/scroll/y: to-integer rows * data
			show p/tree-pane
		]
	]

	tree-hslider-spec: [
		size: (as-pair p/size/x - 15 16)
		options: [arrows]
		action: func [face] [
			p/tree-pane/scroll/x: to-integer root-face/hslider - face/size/x + 2 * data
			show p/tree-pane
		]
	]

	tree-pane-spec: [
		type: 'tree-pane
		scroll: 0x0
		size: (as-pair p/size/x - p/tree-vslider/size/x  p/size/y) - (p/edge/size * 2)
		color: colors/edit
;		edge: default-edge
		feel: make default-feel [
			redraw: func [f a][
				if a = 'show [
					f/tmp-index: 0
				]
			]

			engage: func [f a e /local rows sld][
			    switch a [
		        	up [f/action f]
		        	scroll-line [
						rows: length? f/data
						sld: f/parent-face/tree-vslider
						if any [
							f/scroll/y > 0
							rows > to-integer (f/size/y / f/tree-line/size/y + .5)
						][
							f/scroll/y: max 0 min rows f/scroll/y + (e/offset/y / (abs e/offset/y))
							sld/data: f/scroll/y / rows
							f/parent-face/scroll?: true
							show [f sld]
							f/parent-face/scroll?: false
						]
		        	]
		        ]
		    ]
		]

		focus-action: :on-focus
		unfocus-action: :on-unfocus

		ln: 0
		last-ln: 0
		over?: false

		x-mouse-pos: 0
		tree-ref: none
		exit-action: none
		tree-path: none


		action:	func [face /local act act1 act2 loc-act-result plus-minus-click] [
			if tree-ref [

;				probe x-mouse-pos
;				probe tree-ref/3/1

				ln: 0

				;global action
				root-face/action root-face

				loc-act-result: true

				plus-minus-click: all [x-mouse-pos > tree-ref/3/1 x-mouse-pos < (tree-ref/3/1 + 18)]

				unless plus-minus-click [
					;exit-action
					if exit-action [
						do bind exit-action in root-face 'self
						exit-action: none
					]

					;local action
					either act: select tree-ref/2 'action [
						if parse/all act [set act1 block! set act2 block!] [
							exit-action: act2
							act: act1
						]

						set/any 'loc-act-result do func [] bind act in root-face 'self

						if unset? get/any 'loc-act-result [
							loc-act-result: false
						]
					][
						;no cation block - do only 'alt-action' block
						root-face/alt-action root-face
						hide-tree
						exit
					]
				]
			]

			either all [tree-ref tree-ref/1] [
				either any [loc-act-result plus-minus-click] [
					either tree-ref/1/2 = 'on [
						if plus-minus-click [
							remove at tree-ref/1 2
							remove at tree-ref/2 2
						]
					][
						insert next tree-ref/1 'on
						insert next tree-ref/2 'on
					]

					unless plus-minus-click [
						picked-line: last-ln
						picked: tree-ref/2
						hide-tree
					]

					data: parse-tree p/data
					check-sliders
					show face/parent-face
				][
					hide-tree
				]
			][
				if loc-act-result [
					picked-line: last-ln
					picked: tree-ref/2
					data: parse-tree p/data
				]
				hide-tree
			]
		]

		parse-tree: func [
			data [block!]
			/level
				lvl [integer!]
			/local stack act? sc blk w n c gauge? gauge g-color lines stk x str tree-rule mark on? beg tsiz goft tmp tp? pck mark-stack l last-lines over-box idx act-rule cont action-inherited ai
		][
			action-inherited: none
			gauge?: false
			lines: copy []
			mark-stack: copy []
			stack: copy [0]
			stk: copy []
			x: either gauge-front? [54][2]
			tree-path: copy []
			pck: either picked [
				picked/1
			][
				none ;data/1
			]
			tp?: true
			l: 1
			idx: 0
			root-face/hslider: 0
;			act?: false
			tree-rule: [
				some [
					beg: set str string! (
						idx: idx + 1
						c: w: gauge: sc: blk: none
						on?: false
						change back tail stack (last stack) + 1
						if same? pck str [
							picked-line: idx
							picked-path: copy stack
							insert tail tree-path translate str
							tp?: false
						]
						if action-inherited [insert next beg reduce ['action action-inherited]]
					) any [
						'image set w  [word! | image!]
						| opt 'gauge set n number! set c opt tuple! (gauge: n g-color: c)
						| 'on (on?: true)
						| 'action block! ; (act?: true)
						|  ai: 'action-inherited block! (ai/1: 'action action-inherited: ai/2)
						| 'shortcut set sc block!
						| set blk block! (action-inherited: none)
					] mark: (
						either all [
							level
							lvl >= l
						][
							if all [
								blk
								not find copy/part beg (index? mark) - (index? beg) 'on
							][
								on?: true
								insert next beg 'on
								mark: next mark
							]
						][
							if all [level on? blk] [
								on?: false
								remove find beg 'on
								mark: back mark
							]
						]
						over-box: reduce [x 0]
						insert/only tail lines compose/deep [
							[
								(compose stk)
								image (as-pair x 0) (
									either all [blk not empty? blk] [
										either empty? mark [
											either on? [
												'tree-images/corner-minus
											][
												'tree-images/corner-plus
											]
										][
											either on? [
												insert tail stk compose [image (to-paren (compose [as-pair (x) 0])) tree-images/bar]
												'tree-images/tee-minus
											][
												'tree-images/tee-plus
											]
										]
									][
										either empty? mark [
											'tree-images/corner
										][
											'tree-images/tee
										]
									]
								)
							][
								image (as-pair x + 18 0) (
									either w [
										to-lit-word w
									][
										either blk [
											either on? [
												'tree-images/node-open
											][
												'tree-images/node-closed
											]
										][
											'tree-images/item
										]
									]
								)
								font default-font
								text aliased (as-pair x + 40 0) (translate str)
								(
									over-box/2: tsiz: x + 40 + first size-text make system/standard/face [font: default-font size: 10000x100 text: str]
;									if tsiz > root-face/size/x [
										root-face/hslider: max root-face/hslider tsiz
;									]
									either gauge [
										gauge?: true
										compose [
											pen black
											fill-pen none
											box (goft: either gauge-front? [
													2x2
												][
													either gauge-right? [
														as-pair tsiz + 2 2
													][
														as-pair size/x - 56 2
													]
												]
											) (goft + 51x10)
											pen none
											fill-pen (any [g-color sky])
											box (goft + 1) (goft + 1 + as-pair gauge * .5 9)
										]
									][
									]
								)
							]
						]
						tmp: copy/part beg (index? mark) - (index? beg)
						insert/only last lines reduce either blk [
							act?: false
							cont: none
							parse blk act-rule: [
								some [
									cont [
									'action (act?: true cont: [end skip])
									| 'action-inherited (act?: true cont: [end skip])
									| into act-rule
									| skip
									]
								]
							]
							[beg tmp over-box act?]
						][
							[none tmp over-box]
						]
						if all [on? blk not empty? blk] [
							x: x + 18

							if tp? [
								insert tail tree-path translate str
							]

							insert/only tail mark-stack reduce [mark first last lines]

							l: l + 1

							insert tail stack 0

							parse/all blk tree-rule

							l: l - 1

							remove back tail stack

							mark: first last mark-stack
							last-lines: second last mark-stack
							remove back tail mark-stack
;							insert tail last-lines act?
;							act?: false

							if tp? [
								remove back tail tree-path
							]
						]
					) :mark
				] (
					x: x - 18
					remove/part skip tail stk -3 3
				)
			]
			parse/all data tree-rule
			rows: length? lines

			unless empty? tree-path [
				system/view/highlight-start: system/view/highlight-end: none
				system/view/caret: tail change clear input-field/text to-string to-file tree-path
				show input-field
			]
;			print ">>>PARSE TREE<<<"
;			probe lines
			if all [not gauge-front? gauge?] [
				if all [face/size/x - root-face/hslider < 53 root-face/hslider + 53 > (root-face/size/x - 16)] [
					root-face/hslider: root-face/hslider + 53
					unless gauge-right? [
						foreach l lines [
							if ll: l: find l/3 'box [
								l/2/x: root-face/hslider - 53
								l/3/x: root-face/hslider - 2
								l/10/x: root-face/hslider - 52 + (l/10/x - l/9/x)
								l/9/x: root-face/hslider - 52
							]
						]
					]
				]
			]
			if root-face/hslider <= (root-face/size/x - 16) [
				root-face/hslider: 0
			]
			return lines
		]

		tree-line: make face [
			edge: none
			fx: [draw []]
			fx2: [alphamul 128 draw []]
		]
		tmp-index: 0
		pane: func [face index /local lh tx tpos tsiz idx txt-pen][
			lh: tree-line/size/y
			either integer? index [
				if all [index <= (face/size/y / lh + .5) pick data index + scroll/y] [
					if tmp-index < index [
						tmp-index: index
						tree-line/size: as-pair max face/size/x root-face/hslider  18
						tree-line/offset: as-pair - scroll/x index - 1 * lh
						tree-line/color: white
						tree-line/data: index
						index: index + scroll/y
						txt-pen: either any [find data/:index/1/2 'action data/:index/1/4][
							tree-line/effect: copy tree-line/fx
							black
						][
							tree-line/effect: copy tree-line/fx2
							gray
						]

						tree-line/effect/draw: first next data/:index
						insert tree-line/effect compose/deep [draw [
							(
								either picked = data/:index/1/2 [
									tx: find second next data/:index 'text
									tpos: first skip tx 2
									tsiz: size-text make system/standard/face [font: default-font size: 10000x100 text: first skip tx 3]

									compose [pen white fill-pen silver box (tpos - 2) (tpos + tsiz)]
								][
								]
							)
							pen (txt-pen)
							(
								either all [
									index = ln
									over?
								][
									tree-ref: first data/:ln

									tx: find second next data/:index 'text
									tpos: first skip tx 2
									tsiz: size-text make system/standard/face [font: default-font size: 10000x100 text: first skip tx 3]
									compose [pen white fill-pen blue box (tpos - 2) (tpos + tsiz)]
								][

								]
							)
							(second next data/:index)
							]
						]

					]
					tree-line
				]
			][
				if system/view/focal-face <> face [ctx-rebgui/edit/unfocus system/view/focal-face: face]; ctx-rebgui/edit/focus face]
				unless face/parent-face/scroll? [
					x-mouse-pos: first index + scroll/x
					ln: 1 + second index / lh + scroll/y
					either all [
						ln <= rows
;						x-mouse-pos > data/:ln/1/3/1
;						x-mouse-pos < data/:ln/1/3/2
					][
						if any [
							not over?
							ln <> last-ln
						][
							last-ln: ln
							over?: true
							show self
						]
					][
						if over? [
							tree-ref: none
							over?: false
							show self
						]
					]
				]
			]
		]

		init: does [
			data: parse-tree p/data
		]
	]

	tree-box-spec: [
		size: as-pair root-face/size/x list-lines * 18
		edge: default-edge
		options: [no-title no-border]
;		opts: [no-close-outside]
		tree-pane: tree-hslider: tree-vslider: none
		data: root-face/data
		scroll?: false
		feel: make default-feel [
			detect: func [f e][
				case [
					e/type = 'down [
						f/scroll?: true
					]
					e/type = 'up [
						f/scroll?: false
					]
				]
				e
			]
		    close-events: [close]
    		inside?: func [face event][within? event/offset win-offset? face face/size]
		    process-outside-event: func [face event][
		        unless find [up down move time active inactive scroll-line] event/type [
					unless root-face/expander/active? [
			        	clear-expander
						hide-popup
					]
				]
		        event
		    ]
		    pop-detect: func [face event][
		        either inside? face event [
		            either find close-events event/type [
						clear-expander hide-popup none
					][
						if event/key = #"^[" [clear-expander]
						event
					]
		        ] [
		            process-outside-event face event
		        ]
		    ]
		]
		init: has [p] [
			p: self
			tree-vslider: make slider bind tree-vslider-spec 'p
			tree-hslider: make slider bind tree-hslider-spec 'p
			tree-pane: make rebface bind tree-pane-spec 'p
			tree-vslider-spec: tree-hslider-spec: tree-pane-spec: none
			pane: reduce [tree-pane tree-vslider tree-hslider ]
			foreach face pane [
				face/init
			]
		]
	]

	clear-expander: does [foreach f root-face/expander/pane [f/color: colors/widget f/font/color: black]]

	hide-tree: does [
		clear-expander
		hide-popup
;		system/view/pop-face: none
;		ctx-rebgui/edit/unfocus
		return true
	]

	add-hslider: does [
		tree-box/tree-pane/size/y: tree-box/tree-vslider/size/y: tree-box/size/y - tree-box/tree-hslider/size/y - (2 * tree-box/edge/size/y) + 3
		tree-box/tree-hslider/offset: as-pair -1 tree-box/size/y - tree-box/tree-hslider/size/y - (2 * tree-box/edge/size/y) + 1
		tree-box/tree-hslider/show?: true
	]

	check-sliders: does [

		tree-box/tree-vslider/ratio: min 1 max 0.1 list-lines / (rows + list-lines)

		either root-face/hslider <> 0 [
			add-hslider
		][
			remove-hslider
		]
	]

	remove-hslider: does [
		tree-box/tree-pane/size/y: tree-box/tree-vslider/size/y: tree-box/size/y - (2 * tree-box/edge/size/y) + 2
		tree-box/tree-hslider/show?: false
	]

	show-tree: has [pf oft][
		unless system/view/pop-face [
			tree-box/size/x: root-face/size/x
			tree-box/tree-pane/size/x: root-face/size/x - tree-box/tree-vslider/size/x - (tree-box/edge/size/x * 2) + 1
			tree-box/tree-vslider/offset: as-pair tree-box/size/x - tree-box/tree-vslider/size/x - (2 * tree-box/edge/size/x) + 1 -1

			if picked-line [
				tree-box/tree-pane/scroll/y: max 0 picked-line - 2
				tree-box/tree-vslider/data: tree-box/tree-pane/scroll/y / rows
			]

			check-sliders

			pf: parent-face
			oft: offset
			while [all [pf/parent-face pf/size]][
				oft: oft + pf/offset
				pf: pf/parent-face
			]

			switch popup-mode [
				inside [
					tree-box/offset: oft + as-pair 0 root-face/size/y - 1
					show-popup/window/away tree-box pf
					return true
				]
				outside [
					tree-box/offset: pf/offset + oft + as-pair 0 size/y - input-field/edge/size/y
					show-popup/away tree-box
					return true
				]
			]
			return true
		]
		return false
	]

	node: make object! [
		type: 'node
		text: ""
		gauge: none
		gauge-color: none
		action-enter: none
		action-exit: none
		image: none
		shortcut: none
		data-ref: none
	]

	node-tail: func [
		node [object!]
		/local
			tree-rule fin
	][
		tree-rule: [
			string!
			any [
				'image [word! | image!]
				| opt 'gauge number! opt tuple!
				| 'on
				| 'action block!
				| 'action-inherited block!
				| 'shortcut block!
				|  block!
			] fin:
		]

		parse/all node/data-ref tree-rule
		return fin
	]

	node-path: func [
		node [object!]
		/local
			main-rule tree-rule tr stack path beg blk
	][
		stack: copy [0]
		tree-rule: [
			beg: set str string! (
				blk: none
				change back tail stack (last stack) + 1
				if same? node/data-ref beg [
					path: copy stack
				]
			)
			any [
				'image [word! | image!]
				| opt 'gauge number! opt tuple!
				| 'on
				| 'action block!
				| 'action-inherited block!
				| 'shortcut block!
				|  set blk block!
			] (
				if path [tree-rule: [skip to end]]
				if blk [
					insert tail stack 0
					parse/all blk main-rule
					remove back tail stack
				]
			)
		]

		parse/all data main-rule: [some [(tr: tree-rule) tr]]
		return path
	]

	build-node: func [
		node [object!]
		'end [word! none!]
		/local
			blk act tree-rule fin
	][
		if node/data-ref [
			tree-rule: [
				string!
				any [
					'image [word! | image!]
					| opt 'gauge number! opt tuple!
					| 'on
					| 'action block!
					| 'action-inherited block!
					| 'shortcut block!
					|  set blk block!
				] fin:
			]

			parse/all node/data-ref tree-rule

			set end fin
		]

		return compose [
			(copy node/text)
			(either all [node/type = 'item word? node/image value? node/image] [compose [image (node/image)]][])
			(either node/gauge [compose [gauge (node/gauge)]][])
			(either all [node/gauge node/gauge-color][node/gauge-color][])
			(either all [node/type = 'node node/open?] ['on][])
			(
				act: copy []
				insert/only tail act either block? node/action-enter [
					bind node/action-enter 'system
				][[]]
				insert/only tail act either block? node/action-exit [
					bind node/action-exit 'system
				][[]]
				either all [
					empty? act/1
					empty? act/2
				][][compose/deep [action [(act)]]]
			)
			(either node/type = 'node [reduce either blk [[blk]][[copy []]]][])
		]
	]

	;public API commands

	create-node: has [
		/item
	][
		return make node compose [
			if item [type: 'item]
			(unless item [[open?: false]])
		]
	]

	get-node: func [
		path [string!]
		/local
			result act act1 act2 exit-action stack beg tree-rule str c sc w g blk on? main-rule l n tr
	][
		path: to-block form parse/all path "/"
		stack: copy [0]
		l: 0
		tree-rule: [
			beg: set str string! (
				l: l + 1
				c: w: g: act: blk: none
				change back tail stack (last stack) + 1
				on?: false
			)
			any [
				'image set w [word! | image!]
				| opt 'gauge set n number! set c opt tuple! (g: n)
				| 'on (on?: true)
				| 'action set act block!
				| 'action-inherited set act block!
				| 'shortcut set sc block!
				| set blk block!
			]
			(
				if stack = path [
					tree-rule: [skip to end]
					if all [act parse/all act [set act1 block! set act2 block!]][
						exit-action: act2
						act: act1
					]
					result: make object! compose [
						type: either blk ['node]['item]
						text: copy str
						gauge: g
						gauge-color: any [c if g [sky]]
						action-enter: act
						action-exit: exit-action
						image: :w
						shortcut: none
						(either blk [
							[open?: on?]
						][])
						data-ref: beg
						line: l
					]
				]
				if blk [
					insert tail stack 0
					parse/all blk main-rule
					remove back tail stack
				]
			)
		]
		parse/all data main-rule: [some [(tr: tree-rule) tr]]
		return result
	]

	set-node: func [
		node [object!]
		/local
			blk act tmp-node tree-rule fin
	][
		tmp-node: build-node node fin

		insert remove/part node/data-ref (index? fin) - (index? node/data-ref) tmp-node
		return true
	]


	select-node: func [
		node [object! string!]
		/local tmp path var item i found loc-item line
	][
		if string? node [
			; 1st try to see if we have a numeric path
			tmp: get-node node

			; 2nd try to check if we have a textual path
			either tmp
				[
					path: node
					node: tmp
				][
					var: data
					path: make string! 0
					parse parse node "/" [
						any [
							set item skip (
								loc-item: append copy "<loc>" item
								i: 1
								found: false
								if var [
									parse var [
										any [
											; looking for the item
											[item | loc-item] (
												insert tail path form i
												insert tail path "/"
												found: true
												; this level is no longer needed, next level coming
												var: none
											) any [
												'action block! |
												'action-inherited block! |
												set var block! break | ; use next level
												string! break |
												skip
											] | ; item not found yet
											string! (i: i + 1) | skip
										]
									]
								]

								unless found [
									print [
										"drop-tree set,"
										"item:" item
										"path:" path
									]
									make error! "given text path not in the tree"
								]
							)
						]
					]
					remove back tail path
					node: get-node path
				]
		]

		if node [
			tree-box/tree-pane/parse-tree/level data 0
			either string? path [
				node: parse/all path "/"
			][
				node: node-path node
			]
			path: copy ""
			line: 0
			picked-path: copy []
			foreach n node [
				line: line + to-integer n
				append path n
				append picked-path to-integer n
				n: get-node path
				if n/type = 'node [n/open?: true]
				set-node n
				append path "/"
			]
			update
			picked: second first pick tree-box/tree-pane/data line
			update
			picked-line: line
			return true
		]
		picked: none
		return false
	]

	add-node: func [
		path [string!]
		node [object!]
		/local
			new-ref
	][
		insert new-ref: get in get-node path 'data-ref build-node node none
		node/data-ref: new-ref
		return true
	]

	remove-node: func [
		node [string! object!]
	][
		if string? node [
			node: get-node node
		]
		remove/part node/data-ref (index? node-tail node) - (index? node/data-ref)
	]

	load-tree: func [
		file [file!]
	][
		data: load file
	]

	save-tree: func [
		file [file!]
	][
		save/all file data
	]

	update: has [
		f
	][
		f: tree-box/tree-pane
		f/data: f/parse-tree data
		check-sliders
		show f
	]

	set-list-lines: func [
		lines [integer!]
	][
		list-lines: lines
		tree-box/tree-pane/size/y: (tree-box/size/y: list-lines * 18) - (tree-box/edge/size/y * 2)
		check-sliders
		show parent-face
	]

	get-picked-path: does [
		picked-path
	]

	;end of API

	expander: rows: picked: picked-line: picked-path: root-face: tree-box: drop-arrow: input-field: none
	popup-mode: 'inside ;can be 'outside
	expander-mode: 'big ;can be set to 'small
	list-lines: 10
	hslider: 0
	size: 50x5
	gauge-front?: false
	gauge-right?: false

	feel: make default-feel [
		redraw: func [
			 fac act pos
		][
			if act = 'show [
				fac/update
			]
		]
	]

	reset-action: func [face] [
		tree-box/tree-pane/parse-tree/level data 0
		picked: picked-path: picked-line: none

		clear input-field/text
		clear text

		show self
	]

	init: does [
		if find options [gauge front][gauge-front?: true]
		if find options [gauge back right][gauge-right?: true]
		append options 'no-close-popup
		root-face: self
		drop-arrow: make arrow bind drop-arrow-spec 'root-face
		drop-arrow/span: either all [span find span #W] [#X][none]
		input-field: make rebface bind input-field-spec 'root-face
		input-field/span: all [span case [find span #WP [#WP] find span #W [#W]]]
		text: input-field/text
		expander: make rebface bind expander-spec 'root-face
		tree-box: make rebface bind tree-box-spec 'root-face
		tree-box/init
		drop-arrow-spec: input-field-spec: expander-spec: tree-box-spec: none
		pane: reduce [input-field drop-arrow expander]
		foreach face pane [
			face/init
		]
	]
]


